"use strict";
exports.__esModule = true;
exports.getJasmineV2Adapter = function (scope) {
    var createToBeMatcher = function (name, matcher) {
        return function (util) {
            return {
                compare: function (actual) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    var passes = matcher.apply(void 0, args.concat([actual]));
                    return {
                        message: util.buildFailureMessage.apply(util, [name, passes, actual].concat(args)),
                        pass: passes
                    };
                }
            };
        };
    };
    var createToHaveMatcher = function forKeyAndActualAndTwoExpected(name, matcher) {
        return function (util) {
            return {
                compare: function (actual, key) {
                    var args = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        args[_i - 2] = arguments[_i];
                    }
                    var passes = matcher.apply(void 0, [key].concat(args, [actual]));
                    var message = util
                        .buildFailureMessage.apply(util, [name, passes, actual].concat(args)).replace('Expected', "Expected member \"" + key + "\" of")
                        .replace(' to have ', ' to be ');
                    return { message: message, pass: passes };
                }
            };
        };
    };
    var createJasmineV2Matcher = function (name, matcher) {
        var _a;
        var isMemberMatcher = name.search(/^toHave/) !== -1;
        var adapter = isMemberMatcher ? createToHaveMatcher : createToBeMatcher;
        var matchersByName = (_a = {}, _a[name] = adapter(name, matcher), _a);
        scope.beforeEach(function () {
            scope.jasmine.addMatchers(matchersByName);
        });
        return matchersByName;
    };
    return createJasmineV2Matcher;
};
