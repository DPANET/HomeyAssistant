{"version":3,"file":"serializr.min.js","sources":["../src/utils/invariant.js","../src/utils/utils.js","../src/api/getDefaultModelSchema.js","../src/api/setDefaultModelSchema.js","../src/api/createModelSchema.js","../src/types/primitive.js","../src/constants.js","../src/api/serializable.js","../src/core/serialize.js","../src/core/Context.js","../src/core/deserialize.js","../src/types/object.js","../src/types/reference.js","../src/types/list.js","../src/api/createSimpleSchema.js","../src/core/serializeAll.js","../src/core/cancelDeserialize.js","../src/core/update.js","../src/types/identifier.js","../src/types/date.js","../src/types/alias.js","../src/types/custom.js","../src/types/optional.js","../src/types/map.js","../src/types/mapAsArray.js","../src/types/raw.js"],"sourcesContent":["var formatters = {\n    j: function json(v) {\n        try {\n            return JSON.stringify(v)\n        } catch (error) {\n            return \"[UnexpectedJSONParseError]: \" + error.message\n        }\n    }\n}\n\nexport default function invariant(condition, message) {\n    if (!condition) {\n        var variables = Array.prototype.slice.call(arguments, 2)\n        var variablesToLog = []\n\n        var index = 0\n        var formattedMessage = message.replace(/%([a-zA-Z%])/g, function messageFormatter(match, format) {\n            if (match === \"%%\") return match\n\n            var formatter = formatters[format]\n\n            if (typeof formatter === \"function\") {\n                var variable = variables[index++]\n\n                variablesToLog.push(variable)\n\n                return formatter(variable)\n            }\n\n            return match\n        })\n\n        if (console && variablesToLog.length > 0) {\n            // eslint-disable-next-line no-console\n            console.log.apply(console, variablesToLog)\n        }\n\n        throw new Error(\"[serializr] \" + (formattedMessage || \"Illegal State\"))\n    }\n}\n","import invariant from \"./invariant\"\n\nexport function GUARDED_NOOP(err) {\n    if (err) // unguarded error...\n        throw new Error(err)\n}\n\nexport function once(fn) {\n    var fired = false\n    return function () {\n        if (!fired) {\n            fired = true\n            return fn.apply(null, arguments)\n        }\n        invariant(false, \"callback was invoked twice\")\n    }\n}\n\nexport function parallel(ar, processor, cb) {\n    // TODO: limit parallelization?\n    if (ar.length === 0)\n        return void cb(null, [])\n    var left = ar.filter(function(){ return true }).length // only count items processed by forEach\n    var resultArray = []\n    var failed = false\n    var processorCb = function (idx, err, result) {\n        if (err) {\n            if (!failed) {\n                failed = true\n                cb(err)\n            }\n        } else {\n            resultArray[idx] = result\n            if (--left === 0)\n                cb(null, resultArray)\n        }\n    }\n    ar.forEach(function (value, idx) {\n        processor(value, processorCb.bind(null, idx), idx)\n    })\n}\n\nexport function isPrimitive(value) {\n    if (value === null)\n        return true\n    return typeof value !== \"object\" && typeof value !== \"function\"\n}\n\nexport function isModelSchema(thing) {\n    return thing && thing.factory && thing.props\n}\n\nexport function isPropSchema(thing) {\n    return thing && thing.serializer && thing.deserializer\n}\n\nexport function isAliasedPropSchema(propSchema) {\n    return typeof propSchema === \"object\" && !!propSchema.jsonname\n}\n\nexport function isIdentifierPropSchema(propSchema) {\n    return typeof propSchema === \"object\" && propSchema.identifier === true\n}\n\nexport function isAssignableTo(actualType, expectedType) {\n    while (actualType) {\n        if (actualType === expectedType)\n            return true\n        actualType = actualType.extends\n    }\n    return false\n}\n\nexport function isMapLike(thing) {\n    return thing && typeof thing.keys === \"function\" && typeof thing.clear === \"function\"\n}\n\nexport function getIdentifierProp(modelSchema) {\n    invariant(isModelSchema(modelSchema))\n    // optimization: cache this lookup\n    while (modelSchema) {\n        for (var propName in modelSchema.props)\n            if (typeof modelSchema.props[propName] === \"object\" && modelSchema.props[propName].identifier === true)\n                return propName\n        modelSchema = modelSchema.extends\n    }\n    return null\n}\n\nexport function processAdditionalPropArgs(propSchema, additionalArgs) {\n    if (additionalArgs) {\n        invariant(isPropSchema(propSchema), \"expected a propSchema\")\n        var argNames = [\"beforeDeserialize\", \"afterDeserialize\"]\n        argNames.forEach(function(argName) {\n            if (typeof additionalArgs[argName] === \"function\") {\n                propSchema[argName] = additionalArgs[argName]\n            }\n        })\n    }\n    return propSchema\n}\n\nexport { invariant }\n","import { isModelSchema } from \"../utils/utils\"\n\n/**\n * Returns the standard model schema associated with a class / constructor function\n *\n * @param {object} thing\n * @returns {ModelSchema} model schema\n */\nexport default function getDefaultModelSchema(thing) {\n    if (!thing)\n        return null\n    if (isModelSchema(thing))\n        return thing\n    if (isModelSchema(thing.serializeInfo))\n        return thing.serializeInfo\n    if (thing.constructor && thing.constructor.serializeInfo)\n        return thing.constructor.serializeInfo\n}\n","import { invariant, isModelSchema } from \"../utils/utils\"\n\n/**\n * Sets the default model schema for class / constructor function.\n * Everywhere where a model schema is required as argument, this class / constructor function\n * can be passed in as well (for example when using `object` or `ref`.\n *\n * When passing an instance of this class to `serialize`, it is not required to pass the model schema\n * as first argument anymore, because the default schema will be inferred from the instance type.\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {ModelSchema} modelSchema - a model schema\n * @returns {ModelSchema} model schema\n */\nexport default function setDefaultModelSchema(clazz, modelSchema) {\n    invariant(isModelSchema(modelSchema))\n    return clazz.serializeInfo = modelSchema\n}\n","import { invariant } from \"../utils/utils\"\nimport getDefaultModelSchema from \"./getDefaultModelSchema\"\nimport setDefaultModelSchema from \"./setDefaultModelSchema\"\n\n/**\n * Creates a model schema that (de)serializes an object created by a constructor function (class).\n * The created model schema is associated by the targeted type as default model schema, see setDefaultModelSchema.\n * Its factory method is `() => new clazz()` (unless overriden, see third arg).\n *\n * @example\n * function Todo(title, done) {\n *     this.title = title;\n *     this.done = done;\n * }\n *\n * createModelSchema(Todo, {\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {object} props property mapping\n * @param {function} factory optional custom factory. Receives context as first arg\n * @returns {object} model schema\n */\nexport default function createModelSchema(clazz, props, factory) {\n    invariant(clazz !== Object, \"one cannot simply put define a model schema for Object\")\n    invariant(typeof clazz === \"function\", \"expected constructor function\")\n    var model = {\n        targetClass: clazz,\n        factory: factory || function() {\n            return new clazz()\n        },\n        props: props\n    }\n    // find super model\n    if (clazz.prototype.constructor !== Object) {\n        var s = getDefaultModelSchema(clazz.prototype.constructor)\n        if (s && s.targetClass !== clazz)\n            model.extends = s\n    }\n    setDefaultModelSchema(clazz, model)\n    return model\n}\n","import {invariant, processAdditionalPropArgs} from \"../utils/utils\"\nimport { isPrimitive } from \"../utils/utils\"\n\n/**\n * Indicates that this field contains a primitive value (or Date) which should be serialized literally to json.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: primitive(),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // outputs: { title : \"test\" }\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {ModelSchema}\n */\nexport default function primitive(additionalArgs) {\n    var result = {\n        serializer: function (value) {\n            invariant(isPrimitive(value), \"this value is not primitive: \" + value)\n            return value\n        },\n        deserializer: function (jsonValue, done) {\n            if (!isPrimitive(jsonValue))\n                return void done(\"[serializr] this value is not primitive: \" + jsonValue)\n            return void done(null, jsonValue)\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","import primitive from \"./types/primitive\"\n\n/**\n * In the event that a property needs to be deserialized, but not serialized, you can use the SKIP symbol to omit the property. This has to be used with the custom serializer.\n *\n * @example\n * var schema = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return _.SKIP\n *         },\n *         function(v) {\n *             return v;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(s, { a: 4 }), { });\n * t.deepEqual(_.deserialize(s, { a: 4 }), { a: 4 });\n */\nexport var SKIP = typeof Symbol !== \"undefined\" ? Symbol(\"SKIP\") : { SKIP: true }\n\nexport var _defaultPrimitiveProp = primitive()\n","import { invariant, isPropSchema } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\nimport primitive from \"../types/primitive\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport createModelSchema from \"../api/createModelSchema\"\n\n// Ugly way to get the parameter names since they aren't easily retrievable via reflection\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg\nvar ARGUMENT_NAMES = /([^\\s,]+)/g\n\nfunction getParamNames(func) {\n    var fnStr = func.toString().replace(STRIP_COMMENTS, \"\")\n    var result = fnStr.slice(fnStr.indexOf(\"(\")+1, fnStr.indexOf(\")\")).match(ARGUMENT_NAMES)\n    if(result === null)\n        result = []\n    return result\n}\n\nfunction serializableDecorator(propSchema, target, propName, descriptor) {\n    invariant(arguments.length >= 2, \"too few arguments. Please use @serializable as property decorator\")\n    // Fix for @serializable used in class constructor params (typescript)\n    var factory\n    if (propName === undefined && typeof target === \"function\"\n        && target.prototype\n        && descriptor !== undefined && typeof descriptor === \"number\") {\n        invariant(isPropSchema(propSchema), \"Constructor params must use alias(name)\")\n        invariant(propSchema.jsonname, \"Constructor params must use alias(name)\")\n        var paramNames = getParamNames(target)\n        if (paramNames.length >= descriptor) {\n            propName = paramNames[descriptor]\n            propSchema.paramNumber = descriptor\n            descriptor = undefined\n            target = target.prototype\n            // Create a factory so the constructor is called properly\n            factory = function(context) {\n                var params = []\n                for (var i = 0; i < target.constructor.length; i++) {\n                    Object.keys(context.modelSchema.props).forEach(function (key) {\n                        var prop = context.modelSchema.props[key]\n                        if (prop.paramNumber === i) {\n                            params[i] = context.json[prop.jsonname]\n                        }\n                    })\n                }\n\n                return new (Function.prototype.bind.apply(target.constructor, [null].concat(params)))\n            }\n        }\n    }\n    invariant(typeof propName === \"string\", \"incorrect usage of @serializable decorator\")\n    var info = getDefaultModelSchema(target)\n\n    if (!info || !target.constructor.hasOwnProperty(\"serializeInfo\"))\n        info = createModelSchema(target.constructor, {}, factory)\n    if (info && info.targetClass !== target.constructor)\n        // fixes typescript issue that tends to copy fields from super constructor to sub constructor in extends\n        info = createModelSchema(target.constructor, {}, factory)\n    info.props[propName] = propSchema\n    // MWE: why won't babel work without?\n    if (descriptor && !descriptor.get && !descriptor.set)\n        descriptor.writable = true\n    return descriptor\n}\n\n/**\n * Decorator that defines a new property mapping on the default model schema for the class\n * it is used in.\n *\n * When using typescript, the decorator can also be used on fields declared as constructor arguments (using the `private` / `protected` / `public` keywords).\n * The default factory will then invoke the constructor with the correct arguments as well.\n *\n * @example\n * class Todo {\n *     @serializable(primitive())\n *     title; // shorthand for primitves\n *\n *     @serializable done;\n *\n *     constructor(title, done) {\n *         this.title = title;\n *         this.done = done;\n *     }\n * }\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param arg1\n * @param arg2\n * @param arg3\n * @returns {PropertyDescriptor}\n */\nexport default function serializable(arg1, arg2, arg3) {\n    if (arguments.length === 1) {\n        // decorated with propSchema\n        var propSchema = arg1 === true ? _defaultPrimitiveProp : arg1\n        invariant(isPropSchema(propSchema), \"@serializable expects prop schema\")\n        return serializableDecorator.bind(null, propSchema)\n    } else {\n        // decorated without arguments, treat as primitive\n        return serializableDecorator(primitive(), arg1, arg2, arg3)\n    }\n}\n","import { invariant, isPrimitive } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport { SKIP, _defaultPrimitiveProp } from \"../constants\"\n\n/**\n * Serializes an object (graph) into json using the provided model schema.\n * The model schema can be omitted if the object type has a default model schema associated with it.\n * If a list of objects is provided, they should have an uniform type.\n *\n * @param arg1 class or modelschema to use. Optional\n * @param arg2 object(s) to serialize\n * @returns {object} serialized representation of the object\n */\nexport default function serialize(arg1, arg2) {\n    invariant(arguments.length === 1 || arguments.length === 2, \"serialize expects one or 2 arguments\")\n    var thing = arguments.length === 1 ? arg1 : arg2\n    var schema = arguments.length === 1 ? null : arg1\n    if (Array.isArray(thing)) {\n        if (thing.length === 0)\n            return [] // don't bother finding a schema\n        else if (!schema)\n            schema = getDefaultModelSchema(thing[0])\n        else if (typeof schema !== \"object\")\n            schema = getDefaultModelSchema(schema)\n    } else if (!schema) {\n        schema = getDefaultModelSchema(thing)\n    } else if (typeof schema !== \"object\") {\n        schema = getDefaultModelSchema(schema)\n    }\n    invariant(!!schema, \"Failed to find default schema for \" + arg1)\n    if (Array.isArray(thing))\n        return thing.map(function (item) {\n            return serializeWithSchema(schema, item)\n        })\n    return serializeWithSchema(schema, thing)\n}\n\nexport function checkStarSchemaInvariant(propDef) {\n    invariant(propDef === true || propDef.pattern, \"prop schema '*' can only be used with 'true' or a prop def with a 'pattern': \" + JSON.stringify(propDef))\n}\n\nexport function serializeWithSchema(schema, obj) {\n    invariant(schema && typeof schema === \"object\" && schema.props, \"Expected schema\")\n    invariant(obj && typeof obj === \"object\", \"Expected object\")\n    var res\n    if (schema.extends)\n        res = serializeWithSchema(schema.extends, obj)\n    else {\n        // TODO: make invariant?:  invariant(!obj.constructor.prototype.constructor.serializeInfo, \"object has a serializable supertype, but modelschema did not provide extends clause\")\n        res = {}\n    }\n    Object.keys(schema.props).forEach(function (key) {\n        var propDef = schema.props[key]\n        if (key === \"*\") {\n            serializeStarProps(schema, propDef, obj, res)\n            return\n        }\n        if (propDef === true)\n            propDef = _defaultPrimitiveProp\n        if (propDef === false)\n            return\n        var jsonValue = propDef.serializer(obj[key], key, obj)\n        if (jsonValue === SKIP){\n            return\n        }\n        res[propDef.jsonname || key] = jsonValue\n    })\n    return res\n}\n\nexport function serializeStarProps(schema, propDef, obj, target) {\n    checkStarSchemaInvariant(propDef)\n    for (var key in obj) if (obj.hasOwnProperty(key)) if (!(key in schema.props)) {\n        if ((propDef === true) || (propDef.pattern && propDef.pattern.test(key))) {\n            var value = obj[key]\n            if (propDef === true) {\n                if (isPrimitive(value)) {\n                    target[key] = value\n                }\n            } else if (propDef.props) {\n                var jsonValue = serialize(propDef, value)\n                if (jsonValue === SKIP){\n                    return\n                }\n                // todo: propDef.jsonname could be a transform function on key\n                target[key] = jsonValue\n            } else {\n                var jsonValue = propDef.serializer(value, key, obj)\n                if (jsonValue === SKIP){\n                    return\n                }\n                // todo: propDef.jsonname could be a transform function on key\n                target[key] = jsonValue\n            }\n        }\n    }\n}\n","import { GUARDED_NOOP, once, invariant, isAssignableTo } from \"../utils/utils\"\n\nvar rootContextCache = new WeakMap()\n\nexport default function Context(parentContext, modelSchema, json, onReadyCb, customArgs) {\n    this.parentContext = parentContext\n    this.isRoot = !parentContext\n    this.pendingCallbacks = 0\n    this.pendingRefsCount = 0\n    this.onReadyCb = onReadyCb || GUARDED_NOOP\n    this.json = json\n    this.target = null // always set this property using setTarget\n    this.hasError = false\n    this.modelSchema = modelSchema\n    if (this.isRoot) {\n        this.rootContext = this\n        this.args = customArgs\n        this.pendingRefs = {} // uuid: [{ modelSchema, uuid, cb }]\n        this.resolvedRefs = {} // uuid: [{ modelSchema, value }]\n    } else {\n        this.rootContext = parentContext.rootContext\n        this.args = parentContext.args\n    }\n}\n\nContext.prototype.createCallback = function (fn) {\n    this.pendingCallbacks++\n    // once: defend against user-land calling 'done' twice\n    return once(function (err, value) {\n        if (err) {\n            if (!this.hasError) {\n                this.hasError = true\n                this.onReadyCb(err)\n                rootContextCache.delete(this)\n            }\n        } else if (!this.hasError) {\n            fn(value)\n            if (--this.pendingCallbacks === this.pendingRefsCount) {\n                if (this.pendingRefsCount > 0) {\n                    // all pending callbacks are pending reference resolvers. not good.\n                    this.onReadyCb(new Error(\n                        \"Unresolvable references in json: \\\"\" +\n                        Object.keys(this.pendingRefs).filter(function (uuid) {\n                            return this.pendingRefs[uuid].length > 0\n                        }, this).join(\"\\\", \\\"\") +\n                        \"\\\"\"\n                    ))\n                    rootContextCache.delete(this)\n                } else {\n                    this.onReadyCb(null, this.target)\n                    rootContextCache.delete(this)\n                }\n            }\n        }\n    }.bind(this))\n}\n\n// given an object with uuid, modelSchema, callback, awaits until the given uuid is available\n// resolve immediately if possible\nContext.prototype.await = function (modelSchema, uuid, callback) {\n    invariant(this.isRoot)\n    if (uuid in this.resolvedRefs) {\n        var match = this.resolvedRefs[uuid].filter(function (resolved) {\n            return isAssignableTo(resolved.modelSchema, modelSchema)\n        })[0]\n        if (match)\n            return void callback(null, match.value)\n    }\n    this.pendingRefsCount++\n    if (!this.pendingRefs[uuid])\n        this.pendingRefs[uuid] = []\n    this.pendingRefs[uuid].push({\n        modelSchema: modelSchema,\n        uuid: uuid,\n        callback: callback\n    })\n}\n\n// given a model schema, uuid and value, resolve all references that where looking for this object\nContext.prototype.resolve = function (modelSchema, uuid, value) {\n    invariant(this.isRoot)\n    if (!this.resolvedRefs[uuid])\n        this.resolvedRefs[uuid] = []\n    this.resolvedRefs[uuid].push({\n        modelSchema: modelSchema, value: value\n    })\n    if (uuid in this.pendingRefs) {\n        for (var i = this.pendingRefs[uuid].length - 1; i >= 0; i--) {\n            var opts = this.pendingRefs[uuid][i]\n            if (isAssignableTo(modelSchema, opts.modelSchema)) {\n                this.pendingRefs[uuid].splice(i, 1)\n                this.pendingRefsCount--\n                opts.callback(null, value)\n            }\n        }\n    }\n}\n\n// set target and update root context cache\nContext.prototype.setTarget = function (target) {\n    if (this.isRoot && this.target) {\n        rootContextCache.delete(this.target)\n    }\n    this.target = target\n    rootContextCache.set(this.target, this)\n}\n\n// call all remaining reference lookup callbacks indicating an error during ref resolution\nContext.prototype.cancelAwaits = function () {\n    invariant(this.isRoot)\n    var self = this\n    Object.keys(this.pendingRefs).forEach(function (uuid) {\n        self.pendingRefs[uuid].forEach(function (refOpts) {\n            self.pendingRefsCount--\n            refOpts.callback(new Error(\"Reference resolution canceled for \" + uuid))\n        })\n    })\n    this.pendingRefs = {}\n    this.pendingRefsCount = 0\n}\n\nexport function getTargetContext(target) {\n    return rootContextCache.get(target)\n}\n","/*\n * Deserialization\n */\nimport { invariant, isPrimitive, isModelSchema, parallel, GUARDED_NOOP } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport { SKIP, _defaultPrimitiveProp } from \"../constants\"\nimport Context from \"./Context\"\nimport {checkStarSchemaInvariant} from \"./serialize\";\n\nfunction schemaHasAlias(schema, name) {\n    for (var key in schema.props)\n        if (typeof schema.props[key] === \"object\" && schema.props[key].jsonname === name)\n            return true\n    return false\n}\n\nfunction deserializeStarProps(context, schema, propDef, obj, json) {\n    checkStarSchemaInvariant(propDef)\n    for (var key in json) if (!(key in schema.props) && !schemaHasAlias(schema, key)) {\n        var jsonValue = json[key]\n        if (propDef === true) {\n            // when deserializing we don't want to silently ignore 'unparseable data' to avoid\n            // confusing bugs\n            invariant(isPrimitive(jsonValue),\n                \"encountered non primitive value while deserializing '*' properties in property '\" +\n                key + \"': \" + jsonValue)\n            obj[key] = jsonValue\n        } else if (propDef.pattern.test(key)) {\n            if (propDef.factory) {\n                var resultValue = deserializeObjectWithSchema(context, propDef, jsonValue, context.callback || GUARDED_NOOP, {})\n                // deserializeObjectWithSchema returns undefined on error\n                if (resultValue !== undefined) {\n                    obj[key] = resultValue;\n                }\n            } else {\n                function setValue(resultValue) {\n                    if (resultValue !== SKIP) {\n                        obj[key] = resultValue\n                    }\n                }\n                propDef.deserializer(jsonValue,\n                    // for individual props, use root context based callbacks\n                    // this allows props to complete after completing the object itself\n                    // enabling reference resolving and such\n                    context.rootContext.createCallback(setValue),\n                    context)\n            }\n        }\n    }\n}\n\n/**\n * Deserializes a json structure into an object graph.\n *\n * This process might be asynchronous (for example if there are references with an asynchronous\n * lookup function). The function returns an object (or array of objects), but the returned object\n * might be incomplete until the callback has fired as well (which might happen immediately)\n *\n * @param {object|array} schema to use for deserialization\n * @param {json} json data to deserialize\n * @param {function} callback node style callback that is invoked once the deserialization has\n *   finished. First argument is the optional error, second argument is the deserialized object\n *   (same as the return value)\n * @param {*} customArgs custom arguments that are available as `context.args` during the\n *   deserialization process. This can be used as dependency injection mechanism to pass in, for\n *   example, stores.\n * @returns {object|array} deserialized object, possibly incomplete.\n */\nexport default function deserialize(schema, json, callback, customArgs) {\n    invariant(arguments.length >= 2, \"deserialize expects at least 2 arguments\")\n    schema = getDefaultModelSchema(schema)\n    invariant(isModelSchema(schema), \"first argument should be model schema\")\n    if (Array.isArray(json)) {\n        var items = []\n        parallel(\n            json,\n            function (childJson, itemDone) {\n                var instance = deserializeObjectWithSchema(null, schema, childJson, itemDone, customArgs)\n                // instance is created synchronously so can be pushed\n                items.push(instance)\n            },\n            callback || GUARDED_NOOP\n        )\n        return items\n    } else\n        return deserializeObjectWithSchema(null, schema, json, callback, customArgs)\n}\n\nexport function deserializeObjectWithSchema(parentContext, modelSchema, json, callback, customArgs) {\n    if (json === null || json === undefined || typeof json !== \"object\")\n        return void callback(null, null)\n    var context = new Context(parentContext, modelSchema, json, callback, customArgs)\n    var target = modelSchema.factory(context)\n    // todo async invariant\n    invariant(!!target, \"No object returned from factory\")\n    // TODO: make invariant?            invariant(schema.extends ||\n    // !target.constructor.prototype.constructor.serializeInfo, \"object has a serializable\n    // supertype, but modelschema did not provide extends clause\")\n    context.setTarget(target)\n    var lock = context.createCallback(GUARDED_NOOP)\n    deserializePropsWithSchema(context, modelSchema, json, target)\n    lock()\n    return target\n}\n\nexport function deserializePropsWithSchema(context, modelSchema, json, target) {\n    if (modelSchema.extends)\n        deserializePropsWithSchema(context, modelSchema.extends, json, target)\n\n    function deserializeProp(propDef, jsonValue, propName) {\n\n        function setValue(value) {\n            if (value !== SKIP) {\n                target[propName] = value\n            }\n        }\n\n        function preProcess(resultCallback) {\n            return function (err, newValue) {\n                function finalCallback(errPreliminary, finalOrRetryValue) {\n                    if (errPreliminary && finalOrRetryValue !== undefined &&\n                        typeof propDef.afterDeserialize === \"function\") {\n\n                        propDef.deserializer(\n                            finalOrRetryValue,\n                            preProcess(resultCallback),\n                            context,\n                            target[propName]\n                        )\n                    } else {\n                        resultCallback(errPreliminary, finalOrRetryValue)\n                    }\n                }\n\n                onAfterDeserialize(finalCallback, err, newValue, jsonValue, json,\n                    propName, context, propDef)\n            }\n        }\n\n        propDef.deserializer(\n            jsonValue,\n            // for individual props, use root context based callbacks\n            // this allows props to complete after completing the object itself\n            // enabling reference resolving and such\n            preProcess(context.rootContext.createCallback(setValue)),\n            context,\n            target[propName] // initial value\n        )\n    }\n\n    Object.keys(modelSchema.props).forEach(function (propName) {\n        var propDef = modelSchema.props[propName]\n\n        function callbackDeserialize(err, jsonValue) {\n            if (!err && jsonValue !== undefined) {\n                deserializeProp(propDef, jsonValue, propName)\n            }\n        }\n        if (propName === \"*\") {\n            deserializeStarProps(context, modelSchema, propDef, target, json)\n            return\n        }\n        if (propDef === true)\n            propDef = _defaultPrimitiveProp\n        if (propDef === false)\n            return\n        var jsonAttr = propDef.jsonname || propName\n        var jsonValue = json[jsonAttr]\n        onBeforeDeserialize(callbackDeserialize, jsonValue, json, jsonAttr, context, propDef)\n    })\n}\n\n\nexport function onBeforeDeserialize(\n    callback, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {\n\n    if (propDef && typeof propDef.beforeDeserialize === \"function\") {\n        propDef.beforeDeserialize(callback, jsonValue, jsonParentValue, propNameOrIndex, context,\n            propDef)\n    } else {\n        callback(null, jsonValue)\n    }\n}\n\nexport function onAfterDeserialize(\n    callback, err, newValue, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {\n\n    if (propDef && typeof propDef.afterDeserialize === \"function\") {\n        propDef.afterDeserialize(callback, err, newValue, jsonValue, jsonParentValue,\n            propNameOrIndex, context, propDef)\n    } else {\n        callback(err, newValue)\n    }\n}\n\n","import {invariant, isModelSchema, processAdditionalPropArgs} from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport serialize from \"../core/serialize\"\nimport { deserializeObjectWithSchema } from \"../core/deserialize\"\n\n/**\n * `object` indicates that this property contains an object that needs to be (de)serialized\n * using its own model schema.\n *\n * N.B. mind issues with circular dependencies when importing model schema's from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class SubTask {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: object(SubTask),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: {\n *         title: 'Sub task',\n *     },\n * });\n *\n * @param {ModelSchema} modelSchema to be used to (de)serialize the object\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function object(modelSchema, additionalArgs) {\n    invariant(typeof modelSchema === \"object\" || typeof modelSchema === \"function\", \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\")\n    var result = {\n        serializer: function (item) {\n            modelSchema = getDefaultModelSchema(modelSchema)\n            invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema)\n            if (item === null || item === undefined)\n                return item\n            return serialize(modelSchema, item)\n        },\n        deserializer: function (childJson, done, context) {\n            modelSchema = getDefaultModelSchema(modelSchema)\n            invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema)\n            if (childJson === null || childJson === undefined)\n                return void done(null, childJson)\n            return void deserializeObjectWithSchema(context, modelSchema, childJson, done, additionalArgs)\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","import {invariant, isModelSchema, getIdentifierProp, processAdditionalPropArgs} from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\n\nfunction createDefaultRefLookup(modelSchema) {\n    return function resolve(uuid, cb, context) {\n        context.rootContext.await(modelSchema, uuid, cb)\n    }\n}\n\n/**\n * `reference` can be used to (de)serialize references that point to other models.\n *\n * The first parameter should be either a ModelSchema that has an `identifier()` property (see identifier)\n * or a string that represents which attribute in the target object represents the identifier of the object.\n *\n * The second parameter is a lookup function that is invoked during deserialization to resolve an identifier to\n * an object. Its signature should be as follows:\n *\n * `lookupFunction(identifier, callback, context)` where:\n * 1. `identifier` is the identifier being resolved\n * 2. `callback` is a node style calblack function to be invoked with the found object (as second arg) or an error (first arg)\n * 3. `context` see context.\n *\n * The lookupFunction is optional. If it is not provided, it will try to find an object of the expected type and required identifier within the same JSON document\n *\n * N.B. mind issues with circular dependencies when importing model schemas from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class User {}\n * class Post {}\n *\n * createModelSchema(User, {\n *     uuid: identifier(),\n *     displayname: primitive(),\n * });\n *\n * createModelSchema(Post, {\n *     author: reference(User, findUserById),\n *     message: primitive(),\n * });\n *\n * function findUserById(uuid, callback) {\n *     fetch('http://host/user/' + uuid)\n *         .then(userData => {\n *             deserialize(User, userData, callback);\n *         })\n *         .catch(callback);\n * }\n *\n * deserialize(\n *     Post,\n *     {\n *         message: 'Hello World',\n *         author: 234,\n *     },\n *     (err, post) => {\n *         console.log(post);\n *     }\n * );\n *\n * @param target: ModelSchema or string\n * @param {RefLookupFunction | AdditionalPropArgs} lookupFn optional function or additionalArgs object\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function reference(target, lookupFn, additionalArgs) {\n    invariant(!!target, \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\")\n    var initialized = false\n    var childIdentifierAttribute\n    if (typeof lookupFn === \"object\" && additionalArgs === undefined) {\n        additionalArgs = lookupFn\n        lookupFn = undefined\n    }\n    function initialize() {\n        initialized = true\n        invariant(typeof target !== \"string\" || lookupFn && typeof lookupFn === \"function\", \"if the reference target is specified by attribute name, a lookup function is required\")\n        invariant(!lookupFn || typeof lookupFn === \"function\", \"second argument should be a lookup function or additional arguments object\")\n        if (typeof target === \"string\")\n            childIdentifierAttribute = target\n        else {\n            var modelSchema = getDefaultModelSchema(target)\n            invariant(isModelSchema(modelSchema), \"expected model schema or string as first argument for 'ref', got \" + modelSchema)\n            lookupFn = lookupFn || createDefaultRefLookup(modelSchema)\n            childIdentifierAttribute = getIdentifierProp(modelSchema)\n            invariant(!!childIdentifierAttribute, \"provided model schema doesn't define an identifier() property and cannot be used by 'ref'.\")\n        }\n    }\n    var result = {\n        serializer: function (item) {\n            if (!initialized)\n                initialize()\n            return item ? item[childIdentifierAttribute] : null\n        },\n        deserializer: function(identifierValue, done, context) {\n            if (!initialized)\n                initialize()\n            if (identifierValue === null || identifierValue === undefined)\n                done(null, identifierValue)\n            else\n                lookupFn(identifierValue, done, context)\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","import { SKIP } from \"../constants\"\nimport {\n    invariant,\n    isPropSchema,\n    isAliasedPropSchema,\n    parallel,\n    processAdditionalPropArgs\n} from \"../utils/utils\"\nimport { onAfterDeserialize, onBeforeDeserialize } from \"../core/deserialize\"\nimport { _defaultPrimitiveProp } from \"../constants\"\n\n\n/**\n * List indicates that this property contains a list of things.\n * Accepts a sub model schema to serialize the contents\n *\n * @example\n * class SubTask {}\n * class Task {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: list(object(SubTask)),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: [\n *         {\n *             title: 'Sub task 1',\n *         },\n *     ],\n * });\n *\n * @param {PropSchema} propSchema to be used to (de)serialize the contents of the array\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function list(propSchema, additionalArgs) {\n    propSchema = propSchema || _defaultPrimitiveProp\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\n    invariant(!isAliasedPropSchema(propSchema),\n        \"provided prop is aliased, please put aliases first\")\n    var result = {\n        serializer: function (ar) {\n            if (ar === undefined) {\n                return SKIP\n            }\n            invariant(ar && \"length\" in ar && \"map\" in ar, \"expected array (like) object\")\n            return ar.map(propSchema.serializer)\n        },\n        deserializer: function (jsonArray, done, context) {\n            if (!Array.isArray(jsonArray))\n                return void done(\"[serializr] expected JSON array\")\n\n            function processItem(jsonValue, onItemDone, itemIndex) {\n                function callbackBefore(err, value) {\n                    if (!err) {\n                        propSchema.deserializer(value, deserializeDone, context)\n                    } else {\n                        onItemDone(err)\n                    }\n                }\n\n                function deserializeDone(err, value) {\n                    if (typeof propSchema.afterDeserialize === \"function\") {\n                        onAfterDeserialize(callbackAfter, err, value, jsonValue, itemIndex, context,\n                            propSchema)\n                    } else {\n                        onItemDone(err, value)\n                    }\n                }\n\n                function callbackAfter(errPreliminary, finalOrRetryValue) {\n                    if (errPreliminary && finalOrRetryValue !== undefined &&\n                        typeof propSchema.afterDeserialize === \"function\") {\n\n                        propSchema.deserializer(\n                            finalOrRetryValue,\n                            deserializeDone,\n                            context\n                        )\n                    } else {\n                        onItemDone(errPreliminary, finalOrRetryValue)\n                    }\n                }\n\n                onBeforeDeserialize(callbackBefore, jsonValue, jsonArray, itemIndex, context,\n                    propSchema)\n            }\n\n            parallel(\n                jsonArray,\n                processItem,\n                done\n            )\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","/**\n * Creates a model schema that (de)serializes from / to plain javascript objects.\n * Its factory method is: `() => ({})`\n *\n * @example\n * var todoSchema = createSimpleSchema({\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(todoSchema, { title: 'Test', done: false });\n * var todo = deserialize(todoSchema, json);\n *\n * @param {object} props property mapping,\n * @returns {object} model schema\n */\nexport default function createSimpleSchema(props) {\n    return {\n        factory: function() {\n            return {}\n        },\n        props: props\n    }\n}\n","import { invariant } from \"../utils/utils\"\nimport createModelSchema from \"../api/createModelSchema\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport setDefaultModelSchema from \"../api/setDefaultModelSchema\"\nimport object from \"../types/object\"\n\n/**\n * The `serializeAll` decorator can may used on a class to signal that all primitive properties,\n * or complex properties with a name matching a `pattern`, should be serialized automatically.\n *\n * @example\n * @serializeAll class Store {\n *     a = 3;\n *     b;\n * }\n *\n * const store = new Store();\n * store.c = 5;\n * store.d = {};\n * t.deepEqual(serialize(store), { c: 5 });\n *\n * @example\n * class DataType {\n *     @serializable\n *     x;\n *     @serializable\n *     y;\n * }\n * @serializeAll(/^[a-z]$/, DataType) class ComplexStore {\n * }\n *\n * const store = new ComplexStore();\n * store.a = {x: 1, y: 2};\n * store.b = {};\n * store.somethingElse = 5;\n * t.deepEqual(serialize(store), { a: {x: 1, y: 2}, b: { x: undefined, y: undefined } });\n */\nexport default function serializeAll(targetOrPattern, clazzOrSchema) {\n    let propSchema;\n    let invokeImmediately = false;\n    if (arguments.length === 1) {\n        invariant(typeof targetOrPattern === \"function\", \"@serializeAll can only be used as class decorator\");\n        propSchema = true;\n        invokeImmediately = true;\n    }\n    else {\n        invariant(typeof targetOrPattern === \"object\" && targetOrPattern.test, \"@serializeAll pattern doesn't have test\");\n        if (typeof clazzOrSchema === \"function\") {\n            clazzOrSchema = object(clazzOrSchema);\n        }\n        invariant(typeof clazzOrSchema === \"object\" && clazzOrSchema.serializer, \"couldn't resolve schema\");\n        propSchema = Object.assign({}, clazzOrSchema, {pattern: targetOrPattern})\n    }\n    function result(target) {\n        var info = getDefaultModelSchema(target);\n        if (!info || !target.hasOwnProperty(\"serializeInfo\")) {\n            info = createModelSchema(target, {});\n            setDefaultModelSchema(target, info);\n        }\n        getDefaultModelSchema(target).props[\"*\"] = propSchema;\n        return target;\n    }\n    if (invokeImmediately) {\n        return result(targetOrPattern);\n    }\n    return result;\n}\n","/*\n * Deserialization\n */\nimport { invariant } from \"../utils/utils\"\nimport { getTargetContext } from \"./Context\"\n\n\n/**\n * Cancels an asynchronous deserialization or update operation for the specified target object.\n * @param instance object that was previously returned from deserialize or update method\n */\nexport default function cancelDeserialize(instance) {\n    invariant(typeof instance === \"object\" && instance && !Array.isArray(instance), \"cancelDeserialize needs an object\")\n    var context = getTargetContext(instance)\n    if (context) {\n        context.cancelAwaits()\n    }\n}\n","/*\n * Update\n */\n\nimport { invariant, isModelSchema, GUARDED_NOOP } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport Context from \"./Context\"\nimport { deserializePropsWithSchema } from \"./deserialize\"\n\n/**\n * Similar to deserialize, but updates an existing object instance.\n * Properties will always updated entirely, but properties not present in the json will be kept as is.\n * Further this method behaves similar to deserialize.\n *\n * @param {object} modelSchema, optional if it can be inferred from the instance type\n * @param {object} target target instance to update\n * @param {object} json the json to deserialize\n * @param {function} callback the callback to invoke once deserialization has completed.\n * @param {*} customArgs custom arguments that are available as `context.args` during the deserialization process. This can be used as dependency injection mechanism to pass in, for example, stores.\n * @returns {object|array} deserialized object, possibly incomplete.\n */\nexport default function update(modelSchema, target, json, callback, customArgs) {\n    var inferModelSchema =\n        arguments.length === 2 // only target and json\n        || typeof arguments[2] === \"function\" // callback as third arg\n\n    if (inferModelSchema) {\n        target = arguments[0]\n        modelSchema = getDefaultModelSchema(target)\n        json = arguments[1]\n        callback = arguments[2]\n        customArgs = arguments[3]\n    } else {\n        modelSchema = getDefaultModelSchema(modelSchema)\n    }\n    invariant(isModelSchema(modelSchema), \"update failed to determine schema\")\n    invariant(typeof target === \"object\" && target && !Array.isArray(target), \"update needs an object\")\n    var context = new Context(null, modelSchema, json, callback, customArgs)\n    context.setTarget(target)\n    var lock = context.createCallback(GUARDED_NOOP)\n    var result = deserializePropsWithSchema(context, modelSchema, json, target)\n    lock()\n    return result\n}\n","import { invariant, processAdditionalPropArgs } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\n\nfunction defaultRegisterFunction(id, value, context) {\n    context.rootContext.resolve(context.modelSchema, id, context.target)\n}\n\n/**\n *\n *\n * Similar to primitive, but this field will be marked as the identifier for the given Model type.\n * This is used by for example `reference()` to serialize the reference\n *\n * Identifier accepts an optional `registerFn` with the signature:\n * `(id, target, context) => void`\n * that can be used to register this object in some store. note that not all fields of this object might\n * have been deserialized yet.\n *\n * @example\n * var todos = {};\n *\n * var s = _.createSimpleSchema({\n *     id: _.identifier((id, object) => (todos[id] = object)),\n *     title: true,\n * });\n *\n * _.deserialize(s, {\n *     id: 1,\n *     title: 'test0',\n * });\n * _.deserialize(s, [{ id: 2, title: 'test2' }, { id: 1, title: 'test1' }]);\n *\n * t.deepEqual(todos, {\n *     1: { id: 1, title: 'test1' },\n *     2: { id: 2, title: 'test2' },\n * });\n *\n * @param { RegisterFunction | AdditionalPropArgs } arg1 optional registerFn: function to register this object during creation.\n * @param {AdditionalPropArgs} arg2 optional object that contains beforeDeserialize and/or afterDeserialize handlers\n *\n * @returns {PropSchema}\n */\nexport default function identifier(arg1, arg2) {\n    var registerFn, additionalArgs\n    if (typeof arg1 === \"function\") {\n        registerFn = arg1\n        additionalArgs = arg2\n    } else {\n        additionalArgs = arg1\n    }\n    invariant(!additionalArgs || typeof additionalArgs === \"object\", \"Additional property arguments should be an object, register function should be omitted or a funtion\")\n    var result = {\n        identifier: true,\n        serializer: _defaultPrimitiveProp.serializer,\n        deserializer: function (jsonValue, done, context) {\n            _defaultPrimitiveProp.deserializer(jsonValue, function(err, id) {\n                defaultRegisterFunction(id, context.target, context)\n                if (registerFn)\n                    registerFn(id, context.target, context)\n                done(err, id)\n            })\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","import { invariant, processAdditionalPropArgs } from \"../utils/utils\"\n\n/**\n * Similar to primitive, serializes instances of Date objects\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function date(additionalArgs) {\n    // TODO: add format option?\n    var result = {\n        serializer: function(value) {\n            if (value === null || value === undefined)\n                return value\n            invariant(value instanceof Date, \"Expected Date object\")\n            return value.getTime()\n        },\n        deserializer: function (jsonValue, done) {\n            if (jsonValue === null || jsonValue === undefined)\n                return void done(null, jsonValue)\n            return void done(null, new Date(jsonValue))\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","import { invariant, isPropSchema, isAliasedPropSchema, isIdentifierPropSchema } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\n\n/**\n * Alias indicates that this model property should be named differently in the generated json.\n * Alias should be the outermost propschema.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: alias('task', primitive()),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // { task : \"test\" }\n *\n * @param {string} name name of the json field to be used for this property\n * @param {PropSchema} propSchema propSchema to (de)serialize the contents of this field\n * @returns {PropSchema}\n */\nexport default function alias(name, propSchema) {\n    invariant(name && typeof name === \"string\", \"expected prop name as first argument\")\n    propSchema = (!propSchema || propSchema === true)  ? _defaultPrimitiveProp : propSchema\n    invariant(isPropSchema(propSchema), \"expected prop schema as second argument\")\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is already aliased\")\n    return {\n        jsonname: name,\n        serializer: propSchema.serializer,\n        deserializer: propSchema.deserializer,\n        identifier: isIdentifierPropSchema(propSchema),\n        beforeDeserialize: propSchema.beforeDeserialize,\n        afterDeserialize: propSchema.afterDeserialize\n    }\n}\n","import {invariant, processAdditionalPropArgs} from \"../utils/utils\"\n\n/**\n * Can be used to create simple custom propSchema. Multiple things can be done inside of a custom propSchema, like deserializing and serializing other (polymorphic) objects, skipping the serialization of something or checking the context of the obj being (de)serialized.\n\n * The `custom` function takes two parameters, the `serializer` function and the `deserializer` function.\n\n * The `serializer` function has the signature:\n * `(value, key, obj) => void`\n\n * When serializing the object `{a: 1}` the `serializer` function will be called with `serializer(1, 'a', {a: 1})`.\n\n * The `deserializer` function has the following signature for synchronous processing\n * `(value, context, oldValue) => void`\n\n * For asynchronous processing the function expects the following signature\n * `(value, context, oldValue, callback) => void`\n\n * When deserializing the object `{b: 2}` the `deserializer` function will be called with `deserializer(2, contextObj)` ([contextObj reference](https://github.com/mobxjs/serializr#deserialization-context)).\n *\n * @example\n * var schemaDefault = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v) {\n *             return v - 2;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(schemaDefault, { a: 4 }), { a: 6 });\n * t.deepEqual(_.deserialize(schemaDefault, { a: 6 }), { a: 4 });\n *\n * var schemaWithAsyncProps = _.createSimpleSchema({\n *     a: _.customAsync(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v, context, oldValue, callback) {\n *             somePromise(v, context, oldValue).then((result) => {\n *                 callback(null, result - 2)\n *             }.catch((err) => {\n *                 callback(err)\n *             }\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(schemaWithAsyncProps, { a: 4 }), { a: 6 });\n * _.deserialize(schemaWithAsyncProps, { a: 6 }, (err, res) => {\n *   t.deepEqual(res.a, 4)\n * };\n\n *\n * @param {function} serializer function that takes a model value and turns it into a json value\n * @param {function} deserializer function that takes a json value and turns it into a model value. It also takes context argument, which can allow you to deserialize based on the context of other parameters.\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function custom(serializer, deserializer, additionalArgs) {\n    invariant(typeof serializer === \"function\", \"first argument should be function\")\n    invariant((typeof deserializer === \"function\"), \"second argument should be a function or promise\")\n    var result = {\n        serializer: serializer,\n        deserializer: function (jsonValue, done, context, oldValue) {\n            if (deserializer.length === 4) {\n                deserializer(jsonValue, context, oldValue, done, additionalArgs)\n            } else {\n                done(null, deserializer(jsonValue, context, oldValue, null, additionalArgs))\n            }\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","import { invariant, isPropSchema } from \"../utils/utils\"\nimport { _defaultPrimitiveProp, SKIP } from \"../constants\"\n\n/**\n * Optional indicates that this model property shouldn't be serialized if it isn't present.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: optional(primitive()),\n * });\n *\n * console.dir(serialize(new Todo()));\n * // {}\n *\n * @param {PropSchema} propSchema propSchema to (de)serialize the contents of this field\n * @returns {PropSchema}\n */\nexport default function optional(name, propSchema) {\n    propSchema = (!propSchema || propSchema === true)  ? _defaultPrimitiveProp : propSchema\n    invariant(isPropSchema(propSchema), \"expected prop schema as second argument\")\n    const propSerializer = propSchema.serializer\n    invariant(typeof propSerializer === \"function\", \"expected prop schema to have a callable serializer\")\n    function serializer(...args) {\n        const result = propSerializer(...args)\n        if (result === undefined) {\n            return SKIP\n        }\n        return result\n    }\n    return Object.assign({}, propSchema, {serializer})\n}\n","import {invariant, isAliasedPropSchema, isPropSchema, isMapLike, processAdditionalPropArgs} from \"../utils/utils\"\nimport {_defaultPrimitiveProp} from \"../constants\"\nimport list from \"./list\"\n\n/**\n * Similar to list, but map represents a string keyed dynamic collection.\n * This can be both plain objects (default) or ES6 Map like structures.\n * This will be inferred from the initial value of the targetted attribute.\n *\n * @param {*} propSchema\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function map(propSchema, additionalArgs) {\n    propSchema = propSchema || _defaultPrimitiveProp\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\")\n    var res = {\n        serializer: function (m) {\n            invariant(m && typeof m === \"object\", \"expected object or Map\")\n            var isMap = isMapLike(m)\n            var result = {}\n            if (isMap)\n                m.forEach(function (value, key) {\n                    result[key] = propSchema.serializer(value)\n                })\n            else for (var key in m)\n                result[key] = propSchema.serializer(m[key])\n            return result\n        },\n        deserializer: function (jsonObject, done, context, oldValue) {\n            if (!jsonObject || typeof jsonObject !== \"object\")\n                return void done(\"[serializr] expected JSON object\")\n            var keys = Object.keys(jsonObject)\n            list(propSchema, additionalArgs).deserializer(\n                keys.map(function (key) {\n                    return jsonObject[key]\n                }),\n                function (err, values) {\n                    if (err)\n                        return void done(err)\n                    var isMap = isMapLike(oldValue)\n                    var newValue\n                    if (isMap) {\n                        // if the oldValue is a map, we recycle it\n                        // there are many variations and this way we don't have to\n                        // know about the original constructor\n                        oldValue.clear()\n                        newValue = oldValue\n                    } else\n                        newValue = {}\n                    for (var i = 0, l = keys.length; i < l; i++)\n                        if (isMap)\n                            newValue.set(keys[i], values[i])\n                        else\n                            newValue[keys[i]] = values[i]\n                    done(null, newValue)\n                },\n                context\n            )\n        }\n    }\n    res = processAdditionalPropArgs(res, additionalArgs)\n    return res\n}\n","import { invariant, isPropSchema, isMapLike, processAdditionalPropArgs } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\nimport list from \"./list\"\n\n/**\n * Similar to map, mapAsArray can be used to serialize a map-like collection where the key is\n * contained in the 'value object'. Example: consider Map<id: number, customer: Customer> where the\n * Customer object has the id stored on itself. mapAsArray stores all values from the map into an\n * array which is serialized. Deserialization returns a ES6 Map or plain object object where the\n * `keyPropertyName` of each object is used for keys. For ES6 maps this has the benefit of being\n * allowed to have non-string keys in the map. The serialized json also may be slightly more\n * compact.\n *\n * @param {any} propSchema\n * @param {string} keyPropertyName - the property of stored objects used as key in the map\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function mapAsArray(propSchema, keyPropertyName, additionalArgs) {\n    propSchema = propSchema || _defaultPrimitiveProp\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\n    invariant(!!keyPropertyName, \"expected key property name as second argument\")\n    var res = {\n        serializer: function (m) {\n            invariant(m && typeof m === \"object\", \"expected object or Map\")\n            var isMap = isMapLike(m)\n            var result = []\n            // eslint-disable-next-line no-unused-vars\n            if (isMap) {\n                m.forEach(function (value) {\n                    result.push(propSchema.serializer(value))\n                })\n            } else for (var key in m) {\n                result.push(propSchema.serializer(m[key]))\n                // result[key] = propSchema.serializer(m[key])\n            }\n            return result\n        },\n        deserializer: function (jsonArray, done, context, oldValue) {\n            list(propSchema, additionalArgs).deserializer(\n                jsonArray,\n                function (err, values) {\n                    if (err)\n                        return void done(err)\n                    var isMap = isMapLike(oldValue)\n                    var newValue\n                    if (isMap) {\n                        oldValue.clear()\n                        newValue = oldValue\n                    } else {\n                        newValue = {}\n                    }\n                    for (var i = 0, l = jsonArray.length; i < l; i++)\n                        if (isMap)\n                            newValue.set(values[i][keyPropertyName], values[i])\n                        else\n                            newValue[values[i][keyPropertyName].toString()] = values[i]\n                    done(null, newValue)\n                },\n                context\n            )\n        }\n    }\n    res = processAdditionalPropArgs(res, additionalArgs)\n    return res\n}\n","import {processAdditionalPropArgs} from \"../utils/utils\"\n\n/**\n * Indicates that this field is only need to putted in the serialized json or\n * deserialized instance, without any transformations. Stay with its original value\n *\n * @example\n * createModelSchema(Model, {\n *     rawData: raw(),\n * });\n *\n * console.dir(serialize(new Model({ rawData: { a: 1, b: [], c: {} } } })));\n * // outputs: { rawData: { a: 1, b: [], c: {} } } }\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {ModelSchema}\n */\nexport default function raw(additionalArgs) {\n    var result = {\n        serializer: function (value) {\n            return value\n        },\n        deserializer: function (jsonValue, done) {\n            return void done(null, jsonValue)\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n"],"names":["formatters","j","v","JSON","stringify","error","message","invariant","condition","variables","Array","prototype","slice","call","arguments","variablesToLog","index","formattedMessage","replace","match","format","formatter","variable","push","console","length","log","apply","Error","GUARDED_NOOP","err","parallel","ar","processor","cb","left","filter","resultArray","failed","forEach","value","idx","result","bind","isPrimitive","isModelSchema","thing","factory","props","isPropSchema","serializer","deserializer","isAliasedPropSchema","propSchema","jsonname","isIdentifierPropSchema","identifier","isAssignableTo","actualType","expectedType","extends","isMapLike","keys","clear","processAdditionalPropArgs","additionalArgs","argName","getDefaultModelSchema","serializeInfo","constructor","setDefaultModelSchema","clazz","modelSchema","createModelSchema","Object","model","targetClass","s","primitive","jsonValue","done","SKIP","Symbol","_defaultPrimitiveProp","STRIP_COMMENTS","ARGUMENT_NAMES","serializableDecorator","target","propName","descriptor","fnStr","undefined","paramNames","toString","indexOf","paramNumber","context","params","i","key","prop","json","Function","concat","info","hasOwnProperty","get","set","writable","serialize","arg1","arg2","schema","isArray","map","item","serializeWithSchema","checkStarSchemaInvariant","propDef","pattern","obj","res","test","serializeStarProps","rootContextCache","WeakMap","Context","parentContext","onReadyCb","customArgs","this","isRoot","pendingCallbacks","pendingRefsCount","hasError","rootContext","args","pendingRefs","resolvedRefs","schemaHasAlias","name","deserializeObjectWithSchema","callback","setTarget","lock","createCallback","deserializePropsWithSchema","jsonAttr","onBeforeDeserialize","preProcess","resultCallback","newValue","onAfterDeserialize","errPreliminary","finalOrRetryValue","afterDeserialize","deserializeProp","resultValue","setValue","deserializeStarProps","jsonParentValue","propNameOrIndex","beforeDeserialize","object","childJson","reference","lookupFn","childIdentifierAttribute","initialized","initialize","uuid","await","createDefaultRefLookup","getIdentifierProp","identifierValue","list","jsonArray","onItemDone","itemIndex","deserializeDone","callbackAfter","fn","fired","once","delete","join","resolved","resolve","opts","splice","cancelAwaits","self","refOpts","arg3","targetOrPattern","clazzOrSchema","invokeImmediately","assign","instance","items","itemDone","registerFn","id","defaultRegisterFunction","Date","getTime","oldValue","propSerializer","m","isMap","jsonObject","values","l","keyPropertyName"],"mappings":"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"}